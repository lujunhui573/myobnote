---
share: "true"
---


每当有人问起，学习数据处理应该先学什么，答案都是肯定的：如果已经会了Excel，那就学习Power Query。Power Query本质上是一个ETL工具，就是提取、转换、加载数据的一个工具。对于在业务部门工作的使用来说，对比另一个非常流行的开源ETL工具kettle，Power Query具有非常多的优点：
1. 它是微软的成熟产品Excel与Power BI中的重要组件，与这两个软件完美融合，成熟度非常高。优化也好，无惧于大量业务数据的处理。
2. 它的界面操作设计的很直观，熟悉Excel的用户非常容易上手。好奇心强的小伙伴，甚至可以自己摸索着学习。
3. 它有一些RPA的特征，可以使用界面操作与低代码的输入，重些完成同一类的工作。可以在一定程度上实现一劳永逸的效果。
4. 这个工具极容易调试，你操作过的每一步，都会给你生成一份截止到这一步的结果的预览。当你遇到问题时，可以很容易的找出问题出在哪。哪一步不对改哪里就好了，而其他步骤都不需要做变动。
5. 它的实际功能其实十分健全，虽然通过界面操作已经可以完成很多复杂的工作。但相比于学会内置的M语言，使用M语言来解决问题，那还是冰山一角。
而且，学习Power Query也是学习微软的另一个绝不逊色于Excel的神极软件——Power BI的必经之路。
[Power BI介绍](https://mp.weixin.qq.com/s/rxddbVc2c5KP1rS5ld5XeQ)

### PowerQuery 不仅展现结果，并展现了整个流程，并能自动重复该流程——PQ 具有解释性与可执行性

#### PQ 具有解释性

‌‌‌　　如果一个人是通过手工整理表格完成了工作，它复制粘贴修改的过程不可能保留完整的痕迹。每操作一步保留一个副本也显然不具有可能性，会使得文件过多，反而让过程显得更为繁琐。且需要为每一步都得写上注释，才有可能让另一个（或者事后的自己）通过观察这些步骤的文件与注释，知晓整个处理的过程。

#### PQ 具有可执行性

‌‌‌　　如 [[PowerQuery 优势#PQ 具有解释性|上文]] 所述，PQ 具有解释性，能详细记录处理过程。但是如果它只是仅仅记录了过程，遇到同样的问题时，需要照着这个过程手工一步步重复，那这个工具仍然不够强大。PQ 的强大之处在于它能够自动重复记录下的过程，让许多工作可以一劳永逸。

### PQ 相对于编程语言的优势，可录制——对比 python、VBA

‌‌‌　　[[PowerQuery 优势|上文]] 所述的解释性与可执行性，使用 python 或 VBA 处理表格也具有这些优点。查看 python、VBA 代码即可获知详细的处理过程，运行即可重复完成这些工作。甚至 PQ 的自定义函数，都可以通过 [[利用PQ的录制+低代码完成复杂不规范数据的合并整理|录制+低代码的方式]] 完成。

#### PQ 相比 python 具有可录制的优势

‌‌‌　　学习 python 到利用 python 工作的效率高于直接使用 excel，需要投入成年累月的时间练习。需要花费很大的学习成本才能开始看到收益。一个一边查阅文档，一边调试代码的人，工作效率会比简单地使用 excel 更低。即便成为熟练工，熟练使用 python 对比熟练使用 PQ 也并没有优势。原因在于 PQ 有可视化的界面，可以像使用 VBA 的录制宏功能那样录制代码。PQ 的一些常用功能是不需要手写代码的。

#### PQ 的录制相比 VBA 更专业

##### PQ 录制的代码更精准

‌‌‌　　两者录制功能对目标数据的定位方法不同。VBA 的录制是以单元格区域为对象进行操作，使用“绝对引用”“相对引用”的方式实现灵活引用。这种引用的局限很大，表格结构的稍微变化就会导致原先的代码不能再直接使用。——就比如，插入一列这样的基本操作。 ‌‌‌　　PQ 使用了表格、列表、记录这些数据结构，以列名识别需要操作的列，所录制的代码对数据定位更准确。使得它的代码的更容易复用与套用。

##### PQ 录制的代码更易读，更贴近业务逻辑

‌‌‌　　PQ 预制了很多功能函数，调用这些函数就能完成工作。录制的代码也以这些函数构成。加之两者录制功能对目标数据的定位方法不同。阅读 PQ 录制的代码，能很清楚的看清代码是要做什么，而 VBA 则不然。
```VBA
添加的列 = Table.AddColumn(源，"销售额",each 源[数量]*源[单价])
```

```VBA
Sub 宏1()  
  Range("D1").Select  
  ActiveCell.FormulaR1C1 = "销售额"  
  Range("D2").Select  
  ActiveCell.FormulaR1C1 = "=RC[-2]*RC[-1]"  
  Range("D2").Select  
  Selection.AutoFill Destination:=Range("D2:D3")  
  End Sub
```

‌‌‌　　如上面两段代码，PQ 的逻辑一目了然，而 VBA 如果不结合数据源仔细查看，则看不懂这几行代码是要做什么的。

#### PQ 比 VBA 更容易调试

‌‌‌　　PQ 的每一步结果都可以预览，哪里不对改哪里。而 VBA 的录制需要一口气完成，看不到中间过程，除非熟练使用代码，并编写代码输出中间结果，不然很难调试代码。 ‌

### PQ 有灵活的数据结构

#### PQ 有表格、列表、记录三种数据容器。

列表与 python 的列表相同，记录类似于 python 中的字典，表类似 python 中的 dataframe。 

#### 每个记录可以当作表中的一行，记录的纵向堆积可以变成表格。

类似于 python 代码：

df=pd.Dataframe([{"列名1":a1,"列名2":b1,"列名3":c1},{"列名1":a2,"列名2":b2,"列名3":c2},{"列名1":a3,"列名2":b3,"列名3":c3}])

#### 每个列表可以当作表中的一行，列表的横向堆积可以变成表格。类似 python 中的语法：

类似于 python 代码：

df=pd.Dataframe([{"列名1":[a1,a2,...,an]},{"列名2":[b1,b2,...,bn]},{"列名3":[c1,c2,...,cn]}])

#### PQ 可以很轻松的汇总数据

‌‌‌　　PQ 可以读取一个文件夹的所有文件，生成一个二进制文件的列表{binary1, binary2, ..., binaryn}。 ‌‌‌　　通过简单 PQ 函数使二进制文件（比如，excel 工作簿）变成表格的列表{table1_1, table, 1_2...} 。并最终得到一个表格的列表：{table1_1, table1_2,..., table1_n, table2_1, table2_2,..., table2_n, ..., tableN_1, tableN_2,..., tableN_n}。 ‌‌‌　　通过界面操作即可汇总这个表列列表，形成一个最终的汇总表。这一过程中可以自动对齐相同的列名。即使这些表格中，个别表格多了一些列，少了一些列，列的排布顺序不一致，都不会使得最终的汇总表产生错误。